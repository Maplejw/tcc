异常情况分析
1.2种情况全局事务状态可能为0以及对应的处理方式
a.当获取全局事务ID失败（TCC中心生成了事务ID，但是还没返回就挂了或者业务端获取超时了又或者业务端挂了）
-tcc定时轮询全局事务表，轮询未发送的消息，如果有状态=0，通知各个业务进行cancel,各业务要注意空回滚
b.获取全局事务成功，然后执行各个业务逻辑一半，服务器挂了或者业务逻辑执行完毕但是通知TCC的时候挂了，没通知成功
-tcc定时轮询全局事务表，轮询未发送的消息，如果有状态=0，通过各个业务进行cancel,各业务要注意空回滚

2.全局事务状态为确认或者取消的对应处理方式
a.通知tcc全局事务状态更改为确认或取消，tcc消息未发送出去然后挂了
-tcc全局事务表设置是否发送消息的状态值，轮询未发送的消息，根据全局事务状态进行补发确认还是取消
-tcc需要做到防止同一个事务2次通知的幂等性处理，可以避免出现首次通知确认提交，再次通知确认回滚的情况
update tcc_transcation set status=xxx where transcation_no=xxx and status=0


b.通知成功，全局事务状态更改为确认或取消，消息发送出去然后挂了
-tcc需要做到防止同一个事务2次通知的幂等性处理
update tcc_transcation set status=xxx where transcation_no=xxx and status=0


3.当轮询和通知（有可能程序处理的慢）同时过来时候，需要做到防止消息二次发送
a.通知提交，轮询回滚
-通过update tcc_transcation set status=xxx where transcation_no=xxx and status=0的影响行数来做到防止消息二次发送
b.通知提交，发送kafka挂了，轮询回滚，这个时候轮询没更改事务状态成功，但是把消息发送状态改为已发送，实际未发送
-通过update tcc_transcation set status=xxx where transcation_no=xxx and status=0的影响行数来做到防止消息二次发送且只有修改事务状态成功才能对消息的发送状态进行更改


4.在业务逻辑处理库存、积分的时候，库存预处理完毕，然后程序阻塞了，可以用sleep(100秒)来模拟。这个时候预处理积分还未执行。
而TCC中心有个定时任务轮训全局事务表，发现这个事务到时间了还是初始化状态，就会通知参与者取消，库存系统会进行回滚操作。
但是这个时候积分库还未处理，会进行空回滚，而当100秒sleep结束后，会进行预处理积分，导致积分被扣，状态初始化，造成数据不一致。
a.各个业务也需要配置个定时任务轮训业务事务表，进行轮训回滚
b.不处理的话就是进行人工对账，当出现这个情况告知
c.通过业务确认方将事务隔离级别更改为READ_COMMITTED以及业务表需要对事务ID进行唯一索引创建。判断业务是否有这个事务ID，没有的话则写入。这个时候就看是业务先写进去还是通知先写进去这个事务ID，如果通知先写进去，业务则会抛唯一索引，自动会回滚。如果业务先写进去，则通知会捕获唯一索引，然后进行回滚操作。由于通知先查了未有数据，然后再写遇到业务先写进去，这个时候遇到唯一索引异常，通知再去查询如果不是
READ_COMMITTED事务隔离级别会查询不到数据，因此需要更改为READ_COMMITTED隔离级别，才能正常回滚数据。
-----------------------------------------------------

